<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Poker</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1e3a2f; /* Dark green, like a poker table */
            color: #d4d4d4;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2a523f; /* Lighter dark green */
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 800px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #ffcc00; /* Gold for title */
            margin-bottom: 25px;
            font-size: 2.8em;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
        }

        .player-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #3a6b4f; /* Another shade of green */
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        h2 {
            color: #ffe066; /* Lighter gold for player titles */
            margin-bottom: 15px;
            font-size: 1.6em;
        }

        .hand-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap; /* Allow cards to wrap on smaller screens */
        }

        .card {
            background-color: #fff;
            color: #333;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 1.4em;
            font-weight: bold;
            min-width: 70px; /* Ensure cards have a decent width */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: inline-block; /* Make them behave like blocks for width/padding */
        }

        .card.face-down {
            background-color: #e0e0e0; /* Lighter grey for face down */
            color: #555;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .card.selected-for-draw {
            background-color: #aaffaa; /* Light green when selected */
            border: 2px solid #00aa00;
        }

        .card-value {
            font-size: 0.8em;
            font-weight: normal;
            color: #888;
        }

        .message-area {
            margin: 20px 0;
            font-size: 1.3em;
            font-weight: bold;
            color: #ff8c00; /* Orange for messages */
            min-height: 40px; /* Prevent layout shift */
        }

        .controls button {
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }

        .controls button:hover {
            background-color: #367C39;
            transform: translateY(-2px);
        }

        .controls button:active {
            transform: translateY(0);
        }

        .controls button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

        .card-selection-toggle {
            cursor: pointer;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>Five Card Draw Poker</h1>

        <div id="player-area" class="player-section">
            <h2>Your Hand</h2>
            <div id="player-hand" class="hand-display">
                <!-- Cards will be displayed here -->
            </div>
            <div class="controls">
                <button id="drawButton">Draw Cards</button>
                <button id="nextRoundButton">Next Round</button>
            </div>
        </div>

        <p id="gameMessage" class="message-area"></p>

        <div id="dealer-area" class="player-section" style="display: none;">
            <h2>Dealer's Hand</h2>
            <div id="dealer-hand" class="hand-display">
                <!-- Dealer's hand (hidden initially) -->
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const playerHandElement = document.getElementById('player-hand');
        const gameMessageElement = document.getElementById('gameMessage');
        const drawButton = document.getElementById('drawButton');
        const nextRoundButton = document.getElementById('nextRoundButton');
        const dealerHandElement = document.getElementById('dealer-hand');
        const dealerSection = document.getElementById('dealer-area');

        // --- Game Configuration ---
        const SUITS = ['♥', '♦', '♣', '♠']; // Hearts, Diamonds, Clubs, Spades
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const NUM_SUITS = SUITS.length;
        const NUM_RANKS = RANKS.length;
        const DECK_SIZE = NUM_SUITS * NUM_RANKS;
        const CARDS_PER_HAND = 5;

        // --- Game State ---
        let deck = [];
        let playerHand = [];
        let dealerHand = []; // Simplified: Dealer just gets a hand to show
        let cardsToDrawIndices = []; // Indices of cards the player wants to discard
        let gameOver = false;

        // --- Hand Ranking Scores (Higher is better) ---
        const HAND_RANKS = {
            HIGH_CARD: 1,
            PAIR: 2,
            TWO_PAIR: 3,
            THREE_OF_A_KIND: 4,
            STRAIGHT: 5,
            FLUSH: 6,
            FULL_HOUSE: 7,
            FOUR_OF_A_KIND: 8,
            STRAIGHT_FLUSH: 9,
            ROYAL_FLUSH: 10
        };

        // --- Card Representation ---
        // Example: { rank: 'A', suit: '♥', value: 14 }
        class Card {
            constructor(rank, suit) {
                this.rank = rank;
                this.suit = suit;
                this.value = RANKS.indexOf(rank); // Numerical value for straight checking (2=0, A=12)
            }

            toString() {
                return `${this.rank}${this.suit}`;
            }
        }

        // --- Game Initialization ---
        function createDeck() {
            deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push(new Card(rank, suit));
                }
            }
        }

        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]]; // Swap
            }
        }

        function dealInitialHand() {
            playerHand = [];
            dealerHand = []; // Dealer's hand for display
            cardsToDrawIndices = []; // Reset discard selection

            // Ensure enough cards for two hands
            if (deck.length < CARDS_PER_HAND * 2) {
                console.warn("Not enough cards in deck. Reshuffling.");
                createDeck();
                shuffleDeck();
            }

            for (let i = 0; i < CARDS_PER_HAND; i++) {
                playerHand.push(deck.pop());
                dealerHand.push(deck.pop()); // Deal dealer's hand too
            }
        }

        function setupNewRound() {
            gameOver = false;
            createDeck();
            shuffleDeck();
            dealInitialHand();
            renderPlayerHand();
            dealerSection.style.display = 'none'; // Hide dealer's hand until after player draws
            gameMessageElement.textContent = "Select cards to discard (or none) by clicking them, then press 'Draw Cards'.";
            drawButton.disabled = false;
            nextRoundButton.disabled = true;
        }

        // --- Rendering Functions ---
        function renderPlayerHand() {
            playerHandElement.innerHTML = ''; // Clear current hand display

            playerHand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.dataset.index = index; // Store index for selection
                cardElement.innerHTML = `
                    <span class="card-value">${card.rank}</span>
                    <span class="card-suit">${card.suit}</span>
                `;

                // Toggle selection for drawing
                if (cardsToDrawIndices.includes(index)) {
                    cardElement.classList.add('selected-for-draw');
                }

                cardElement.addEventListener('click', toggleCardSelectionForDraw);
                playerHandElement.appendChild(cardElement);
            });
        }

        function toggleCardSelectionForDraw(event) {
            if (gameOver || !playerHandElement.contains(event.target.closest('.card'))) return; // Ignore clicks on non-cells or if game over

            const cardElement = event.target.closest('.card'); // Ensure we get the card element
            const index = parseInt(cardElement.dataset.index);

            if (cardsToDrawIndices.includes(index)) {
                // Remove from selection
                cardsToDrawIndices = cardsToDrawIndices.filter(i => i !== index);
                cardElement.classList.remove('selected-for-draw');
            } else {
                // Add to selection (limit to 5 cards if somehow more are selected)
                if (cardsToDrawIndices.length < CARDS_PER_HAND) {
                    cardsToDrawIndices.push(index);
                    cardElement.classList.add('selected-for-draw');
                }
            }
            console.log("Cards selected for draw:", cardsToDrawIndices);
        }

        function renderHiddenHand(handArray, element) {
            element.innerHTML = '';
            handArray.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card', 'face-down');
                cardElement.innerHTML = `
                    <span class="card-value">?</span>
                    <span class="card-suit">?</span>
                `;
                element.appendChild(cardElement);
            });
        }

        function renderRevealedHand(handArray, element) {
            element.innerHTML = '';
            handArray.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.innerHTML = `
                    <span class="card-value">${card.rank}</span>
                    <span class="card-suit">${card.suit}</span>
                `;
                element.appendChild(cardElement);
            });
        }


        // --- Game Logic ---
        function drawCards() {
            if (gameOver) return;

            // Remove selected cards from player's hand
            // Sort indices in descending order to avoid issues with shifting array during splice
            cardsToDrawIndices.sort((a, b) => b - a);

            // Deal new cards to replace discarded ones
            for (const index of cardsToDrawIndices) {
                if (deck.length === 0) {
                    console.warn("Deck is empty! Reshuffling.");
                    createDeck();
                    shuffleDeck();
                }
                playerHand[index] = deck.pop();
            }

            cardsToDrawIndices = []; // Clear selection
            renderPlayerHand(); // Re-render hand with new cards
            gameMessageElement.textContent = "Hand processed. Click 'Evaluate Hand' to see your result.";
            drawButton.disabled = true; // Disable draw button until next round
            nextRoundButton.disabled = false; // Enable evaluation button
        }

        // --- Hand Evaluation Functions ---
        // Helper to count occurrences of each rank in a hand
        function getRankCounts(hand) {
            const counts = {};
            for (const card of hand) {
                counts[card.rank] = (counts[card.rank] || 0) + 1;
            }
            // Return sorted counts for easier checking (e.g., [5] for high card, [2, 1, 1, 1] for pair)
            return Object.values(counts).sort((a, b) => b - a);
        }

        // Helper to check for a flush (all cards same suit)
        function isFlush(hand) {
            return hand.every(card => card.suit === hand[0].suit);
        }

        // Helper to check for a straight (consecutive ranks)
        function isStraight(hand) {
            const values = hand.map(card => card.value).sort((a, b) => a - b);
            // Check for standard straight
            let isRegularStraight = true;
            for (let i = 0; i < values.length - 1; i++) {
                if (values[i+1] !== values[i] + 1) {
                    isRegularStraight = false;
                    break;
                }
            }
            if (isRegularStraight) return true;

            // Check for A-2-3-4-5 straight (Ace low)
            const aceLowValues = values.map(v => v === RANKS.length - 1 ? -1 : v).sort((a, b) => a - b); // A=12 becomes -1
            if (aceLowValues[0] === -1 && aceLowValues[1] === 0 && aceLowValues[2] === 1 && aceLowValues[3] === 2 && aceLowValues[4] === 3) {
                 return true; // Ace-low straight (A-2-3-4-5)
            }

            return false;
        }

        // Main hand evaluation function
        function evaluateHand(hand) {
            const rankCounts = getRankCounts(hand);
            const flush = isFlush(hand);
            const straight = isStraight(hand);
            const values = hand.map(card => card.value).sort((a, b) => a - b); // Sorted numerical values

            // Royal Flush (A, K, Q, J, 10 of same suit)
            if (straight && flush && values[4] === RANKS.length - 1 && values[0] === RANKS.length - 5) {
                return { rank: HAND_RANKS.ROYAL_FLUSH, description: "Royal Flush" };
            }

            // Straight Flush (Consecutive cards of same suit)
            if (straight && flush) {
                return { rank: HAND_RANKS.STRAIGHT_FLUSH, description: "Straight Flush" };
            }

            // Four of a Kind (four cards of same rank)
            if (rankCounts[0] === 4) {
                return { rank: HAND_RANKS.FOUR_OF_A_KIND, description: "Four of a Kind" };
            }

            // Full House (three of one rank, two of another)
            if (rankCounts[0] === 3 && rankCounts[1] === 2) {
                return { rank: HAND_RANKS.FULL_HOUSE, description: "Full House" };
            }

            // Flush (all cards same suit, but not straight)
            if (flush) {
                return { rank: HAND_RANKS.FLUSH, description: "Flush" };
            }

            // Straight (consecutive ranks, but not same suit)
            if (straight) {
                return { rank: HAND_RANKS.STRAIGHT, description: "Straight" };
            }

            // Three of a Kind (three cards of one rank)
            if (rankCounts[0] === 3) {
                return { rank: HAND_RANKS.THREE_OF_A_KIND, description: "Three of a Kind" };
            }

            // Two Pair
            if (rankCounts[0] === 2 && rankCounts[1] === 2) {
                return { rank: HAND_RANKS.TWO_PAIR, description: "Two Pair" };
            }

            // Pair
            if (rankCounts[0] === 2) {
                return { rank: HAND_RANKS.PAIR, description: "Pair" };
            }

            // High Card
            return { rank: HAND_RANKS.HIGH_CARD, description: "High Card" };
        }

        // --- Game Flow Control ---
        function evaluateAndShowResults() {
            if (gameOver) return;

            gameOver = true; // End the active game

            const playerEvaluation = evaluateHand(playerHand);
            renderRevealedHand(playerHand, playerHandElement); // Show player's final hand
            dealerSection.style.display = 'block'; // Show dealer's section
            renderRevealedHand(dealerHand, dealerHandElement); // Show dealer's final hand

            const dealerEvaluation = evaluateHand(dealerHand);

            let message = `${playerEvaluation.description} vs ${dealerEvaluation.description}. `;

            if (playerEvaluation.rank > dealerEvaluation.rank) {
                message += "You Win!";
            } else if (playerEvaluation.rank < dealerEvaluation.rank) {
                message += "Dealer Wins!";
            } else {
                // Tie-breaker logic could go here (e.g., compare highest cards, but for simplicity, we'll just call it a tie)
                message += "It's a Tie!";
            }

            gameMessageElement.textContent = message;
            drawButton.disabled = true;
            nextRoundButton.disabled = false; // Keep it enabled for starting a new round
        }

        function startNextRound() {
             setupNewRound();
        }

        // --- Event Listeners ---
        drawButton.addEventListener('click', drawCards);
        nextRoundButton.addEventListener('click', evaluateAndShowResults); // Changed to evaluate after player draws
        // Initial setup when the page loads
        setupNewRound();

    </script>

</body>
</html>
